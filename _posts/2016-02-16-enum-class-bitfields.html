---
layout: post
title: Enum class bitfields
date: 2016-02-16 02:15:51.000000000 -05:00
author: dalzhim
---
<p>C++11's addition of scoped enumeration has given us the ability to create stronger types that can't be accidentally converted between integer types and enumeration types.</p>
<p>[code language="cpp"]<br />
enum e<br />
{<br />
    kEnumerator1,<br />
    kEnumerator2<br />
};</p>
<p>int i = kEnumerator2; // implicit conversion<br />
[/code]</p>
<p>It also prevents namespaces from being polluted by the enumerators as the enumerators are only accessible through the enum type like this :</p>
<p>[code language="cpp"]<br />
enum class eClass<br />
{<br />
    kEnumerator1,<br />
    kEnumerator2<br />
};</p>
<p>eClass e = eClass::kEnumerator1;<br />
[/code]</p>
<p>The main irritant when using scoped enumerations is that it doesn't work well with bitfields. Because enumerators are strongly typed, bitwise operators cannot be used the same way it is done with unscoped enumerators. This strong typing prevents an implicit conversion to an integer type which can be used with bitwise operators. Following this logic, everything works fine with explicit conversions.</p>
<p>[code language="cpp"]<br />
enum class eClass<br />
{<br />
    kEnumerator1 = 1 &lt;&lt; 0,<br />
    kEnumerator2 = 1 &lt;&lt; 1<br />
};</p>
<p>eClass flag = eClass::kEnumerator1 &amp; eClass::kEnumerator2; // Compilation error<br />
eClass flag = static_cast&lt;eClass&gt;(static_cast&lt;int&gt;(eClass::kEnumerator1) &amp; static_cast&lt;int&gt;(eClass::kEnumerator2)); // Success with explicit conversions<br />
[/code]</p>
<p>All those static_casts are tedious so we need something better. Here is my preferred solution which I’ll explain further below :</p>
<p>[code language="cpp"]<br />
template&lt;typename T&gt;<br />
struct enable_enum_class_bitfield<br />
{<br />
    static constexpr bool value = false;<br />
};</p>
<p>template&lt;typename T&gt;<br />
typename std::enable_if&lt;std::is_enum&lt;T&gt;::value &amp;&amp; enable_enum_class_bitfield&lt;T&gt;::value, T&gt;::type<br />
operator&amp;(T lhs, T rhs)<br />
{<br />
	typedef typename std::underlying_type&lt;T&gt;::type integer_type;<br />
	return static_cast&lt;T&gt;(static_cast&lt;integer_type&gt;(lhs) &amp; static_cast&lt;integer_type&gt;(rhs));<br />
}</p>
<p>enum class eClass<br />
{<br />
    kEnumerator1 = 1 &lt;&lt; 0,<br />
    kEnumerator2 = 1 &lt;&lt; 1<br />
};<br />
template&lt;&gt;<br />
struct enable_enum_class_bitfield&lt;eClass&gt;<br />
{<br />
    static constexpr bool value = true;<br />
};</p>
<p>eClass flag = eClass::kEnumerator1 &amp; eClass::kEnumerator2;<br />
[/code]</p>
<p>This operator overload template is meant to generate functions that will allow us to combine instances of an enum class’s enumerators using the familiar bitwise operators. Using SFINAE, we restrict the generation of those methods to types for which T is an enum type and the enable_enum_class_bitfield::value bool is true. In order to fulfill this second condition, a template specialization of the struct enable_enum_class_bitfield is required for the enum type on which we wish to enable bitwise operators. A macro is provided in order to make it easy to enable the bitwise operators without any knowledge about template specializations. This setup has the advantage of having no impact except where the programmer explicitly opts-in to the desired behavior.</p>
<p><strong>Lines 1-5 :</strong> Base definition of the enable_enum_class_bitfield where the initial value is false. This means that all types for which there is no specialization will opt-out of the bitwise operators.<br />
<strong>Line 8 :</strong> Application of <a href="http://en.cppreference.com/w/cpp/language/sfinae" target="_blank">SFINAE</a> to enable operators only for specific types. There are two conditions: first, the type needs to be an enum type; second, the enable_enum_class_bitfields must be specialized to opt-in. Only then will the std::enable_if&lt;…&gt;::type expression resolve to T which is the appropriate return type for the operator overload.<br />
<strong> Line 9 :</strong> Standard operator overload.<br />
<strong> Line 11 :</strong> std::underlying_type::type resolves to the integer type backing the enum. This could be variety of types such as int, long, long long, unsigned variants, etc. This typedef allows us to cast enumerators to the corresponding integer type without any truncation problems in order to apply the bitwise operations.<br />
<strong> Line 12 :</strong> Here we simply cast the enumerators to the underlying type, we apply the bitwise operator and we cast back into an enumerator.<br />
<strong> Lines 20-24 :</strong> Specialization of the enable_enum_class_bitfield to opt-in into bitwise operators for enum type eClass.<br />
<strong> Line 26 :</strong> Usage of the bitwise enumerator.</p>
<p>Finally, all that is left to do is to apply this solution for every bitwise operator : &amp;, |, ^, ~, &amp;=, |=, ^=. You can find the <a href="https://github.com/Dalzhim/ArticleEnumClass" target="_blank">complete source</a> on github.</p>
