---
layout: post
title: Predicate creation techniques for standard algorithms
date: 2015-08-22 18:02:23.000000000 -04:00
type: post
published: true
status: publish
categories:
- Non classé
tags: []
meta:
  _rest_api_published: '1'
  _rest_api_client_id: "-1"
  _publicize_job_id: '13994290101'
author:
  login: dalzhim
  email: dalzhim@hotmail.com
  display_name: dalzhim
  first_name: ''
  last_name: ''
---
<p>Predicates are functions that return a boolean result upon being called. A predicate example is a function <code>bool isToday(Date&amp; date)</code> which returns if the supplied date object corresponds to the current day or not. The Standard Template Library (STL) has many algorithms to which predicates can be supplied : <code>count_if</code>, <code>find_if</code>, <code>copy_if</code>, <code>remove_if</code>, etc. You might have noticed the examples I have given share the suffix <code>_if</code> which hints to the presence of an argument which is a predicate. In this article, I will go over many different ways to implement a predicate that can be supplied to the STL algorithms in order to extract some elements from a collection. First, here is the collection that will be filtered :</p>
<p>[code language="cpp"]class A<br />
{<br />
};<br />
class B<br />
{<br />
public:<br />
    B(int i, A* a) : i(i), a(a) {}</p>
<p>    A* getA() {return a;}</p>
<p>public:<br />
    int i;<br />
    A* a;<br />
};<br />
std::unique_ptr&lt;A&gt; a1 = std::make_unique&lt;A&gt;();<br />
std::unique_ptr&lt;A&gt; a2 = std::make_unique&lt;A&gt;();<br />
std::vector&lt;std::unique_ptr&lt;B&gt;&gt; owningVector;<br />
owningVector.reserve(6);<br />
owningVector.emplace_back(new B(1, a1.get()));<br />
owningVector.emplace_back(new B(2, a2.get()));<br />
owningVector.emplace_back(new B(3, a1.get()));<br />
owningVector.emplace_back(new B(4, a2.get()));<br />
owningVector.emplace_back(new B(5, a1.get()));<br />
owningVector.emplace_back(new B(6, nullptr));</p>
<p>std::vector&lt;B*&gt; objects; // Source collection<br />
objects.reserve(owningVector.size());<br />
std::for_each(owningVector.begin(), owningVector.end(), [&amp;objects](std::unique_ptr&lt;B&gt;&amp; b) {<br />
     objects.push_back(b.get());<br />
});<br />
std::vector&lt;B*&gt; result; // Destination collection[/code]</p>
<p>The first way we might implement a predicate is the implementation of a function. This technique allows the implementation of a simple condition without too much boilerplate. Here is a predicate to identify instances of <code>B</code> that do not have an associated instance of <code>A</code>.</p>
<p>[code language="cpp"]bool predicate0(B* b)<br />
{<br />
    return b-&gt;getA() == nullptr;<br />
}<br />
[/code]</p>
<p>With <code>predicate0</code>, it is possible to use <code>std::copy_if</code> to copy the matching elements into a result collection. <code>std::copy_if</code> has 4 parameters : <code>first</code>, <code>last</code>, <code>output</code> and <code>predicate</code>. <code>first</code> and <code>last</code> are both iterators that define the range over which the algorithm will iterate. <code>output</code> is an <a href="http://en.cppreference.com/w/cpp/concept/OutputIterator">OutputIterator</a> used to copy elements into a destination collection. In order to supply an OutputIterator, one is constructed using <code><a href="http://en.cppreference.com/w/cpp/iterator/back_inserter">std::back_inserter</a></code>. This will append matching elements at the end of the destination collection. Finally, <code>predicate</code> is the function that will return true or false.</p>
<p>[code language="cpp" highlight="5"]std::copy_if(<br />
    objects.begin(),<br />
    objects.end(),<br />
    std::back_inserter(result),<br />
    predicate0<br />
);</p>
<p>// Result : {6}[/code]</p>
<p>After executing <code>std::copy_if</code>, a single instance of <code>B</code> is copied into the destination collection and it has the value 6. It was pretty simple, but this technique is also pretty limited. If we wanted to filter out all the instances of <code>B</code> which are associated with a specific instance of <code>A</code>, it would require a static variable and it wouldn't be <a href="https://en.wikipedia.org/wiki/Thread_safety">thread-safe</a>. The problem is that our function cannot hold any state.</p>
<p>In order to hold an associated state with a predicate function, a <a href="https://en.wikipedia.org/wiki/Function_object">functor</a> can be implemented. A functor is a  function object that solves the problem of having a state. It can serve as an ordinary function because it implements <code>operator()</code>. In the context of this article's example, the functor will consist in a new <code>struct</code> that has an instance variable of type <code>A*</code>. Then, within the <code>struct</code>'s <code>operator()</code> definition, this instance variable will be compared to the elements of the collection.</p>
<p>[code language="cpp"]struct Functor<br />
{<br />
    Functor(A* a) : a(a) {}</p>
<p>    bool operator()(B* b) const<br />
    {<br />
        return b-&gt;getA() == a;<br />
    }</p>
<p>public:<br />
    A* a;<br />
};<br />
[/code]</p>
<p>By implementing <code>operator()</code>, instances of <code>struct Functor</code> are now <a href="http://en.cppreference.com/w/cpp/concept/Callable">Callable</a>. The Callable concept encompasses everything that can be called as an ordinary function. As an example, here is how <code>struct Functor</code> can be called:</p>
<p>[code language="cpp"]std::unique_ptr&lt;B&gt; someBInstance = std::make_unique&lt;B&gt;();<br />
Functor myFunctor(a1.get());<br />
bool result = myFunctor(someBInstance.get());[/code]</p>
<p>And this is precisely what the <code>std::copy_if</code> algorithm will do: it will call the predicate by passing every element of the range <code>[first, last)</code> and evaluate the result of the function to decide whether to copy the element or not. Thus, all the instances of <code>B</code> associated with a specific instance of <code>A</code> can now be copied into the destination collection using the following expressions:</p>
<p>[code language="cpp" highlight="5,14"]std::copy_if(<br />
    objects.begin(),<br />
    objects.end(),<br />
    std::back_inserter(result),<br />
    Functor(a1.get())<br />
);</p>
<p>// Result : {1, 3, 5}</p>
<p>std::copy_if(<br />
    objects.begin(),<br />
    objects.end(),<br />
    std::back_inserter(result),<br />
    Functor(a2.get())<br />
);</p>
<p>// Result : {2, 4}<br />
[/code]</p>
<p>This is much more flexible than using functions, but there's also a lot more boilerplate to write (i. e.: the class, the instance variables and the constructor). But there is a solution to this problem: <a href="http://en.cppreference.com/w/cpp/language/lambda">lambdas</a>. Lambdas can be used to create anonymous functors with a very succinct syntax: <code>[Capture](Parameters) -&gt; ReturnType {Code}</code>. <code>Capture</code> is a comma separated list of variables for which the anonymous class will have corresponding instance variables. <code>Parameters</code> is the list of parameters that the anonymous class's <code>operator()</code> function will accept. <code>ReturnType</code> is going to be the return type of the <code>operator()</code> function. Finally, <code>Code</code> will be the body of the <code>operator()</code> function. In other words, here is how a lambda looks like:</p>
<p>[code language="cpp"]struct COMPILER_GENERATED_NAME {<br />
    COMPILER_GENERATED_NAME(T1 Capture1, T2 Capture2, …, TN CaptureN) : _instance1(Capture1), _instance2(Capture2), …, instanceN(CaptureN) {}</p>
<p>    ReturnType operator()(Parameter1, Parameter2, …, ParameterN) const<br />
    {<br />
        Code<br />
    }</p>
<p>    T1 instance1;<br />
    T2 instance2;<br />
    …<br />
    TN instanceN;<br />
};[/code]</p>
<p>The <code>struct Functor</code> created earlier can be defined much more concisely with a lambda in this way:</p>
<p>[code language="cpp" highlight="6"]auto predicate1 = [a2](B* b) -&gt; bool {return b-&gt;getA() == a2.get();};<br />
std::copy_if(<br />
    objects.begin(),<br />
    objects.end(),<br />
    std::back_inserter(result),<br />
    predicate1<br />
);</p>
<p>// Result : {2, 4}[/code]</p>
<p>This solution with a lambda expression is perfectly fine and some might prefer sticking to it because it is relatively easy to maintain. For the purpose of this article, there is an equivalent solution using the <a href="https://en.wikipedia.org/wiki/Generic_programming">generic programming</a> paradigm. This is somewhat more complex, so let's first decompose the lambda expression in <code>predicate1</code> in its smallest parts.</p>
<ol>
<li><code>B</code>'s <code>getA()</code> method is called</li>
<li>A comparison using operator== is performed on the variable <code>a</code> captured by the lambda expression, and with the result of the <code>getA()</code> method call</li>
</ol>
<p>It is simpler to make the second operation generic because the STL already provides a functor that does that job for us : <code>std::equal_to</code>. As an example, we could rewrite the lambda expression using this functor:</p>
<p>[code language="cpp" highlight="8"]auto predicate2 = [a1](B* b) -&gt; bool {<br />
    return std::equal_to&lt;A*&gt;()(b-&gt;getA(), a1.get());<br />
};<br />
std::copy_if(<br />
    objects.begin(),<br />
    objects.end(),<br />
    std::back_inserter(result),<br />
    predicate2<br />
);</p>
<p>// Result : {1, 3, 5}[/code]</p>
<p>When used as a function, the <code>std::equal_to&lt;A*&gt;</code>'s signature is <code>bool(A*, A*)</code>. It is a function that receives two pointers of <code>A</code> and returns a <code>bool</code>. The predicate expected by an algorithm is a UnaryFunction, so the expected signature is <code>bool(B*)</code>. In order to supply the <code>std::equal_to</code> functor as a predicate to <code>std::copy_if</code>, both the functor and an instance of A must be wrapped in an enclosing functor. So how can a functor be passed as an argument, and how can it be stored in an instance variable? The answer is <code>std::function</code>, which is a generic function wrapper that can wrap any callable object (functions, functors, lambdas, bind expressions, etc.). The <code>std::function</code> functor must be templated on the method signature for which it can wrap <code>Callable</code> instances like this: <code>std::function&lt;bool(A*, A*)&gt;</code>. Here is a functor example that can wrap another functor using <code>std::function</code>:</p>
<p>[code language="cpp"]struct FunctorWrapper<br />
{<br />
    FunctorWrapper(std::function&lt;bool(A*, A*)&gt; functor, A* a) : functor(functor), a(a) {}</p>
<p>    bool operator()(B* b) const<br />
    {<br />
        return functor(a, b-&gt;getA());<br />
    }</p>
<p>public:<br />
    std::function&lt;bool(A*, A*)&gt; functor;<br />
    A* a;<br />
};[/code]</p>
<p><code>FunctorWrapper</code> can now be used as a predicate for the <code>std::copy_if</code> algorithm:</p>
<p>[code language="cpp" highlight="5"]std::copy_if(<br />
    objects.begin(),<br />
    objects.end(),<br />
    std::back_inserter(result),<br />
    FunctorWrapper(std::equal_to&lt;A*&gt;(), a2.get())<br />
);</p>
<p>// Result : {2, 4}[/code]</p>
<p>Once again, writing functors is a lot of boilerplate to write, and the STL offers a solution: <code>std::bind</code>. This functor factory makes it possible to wrap a Callable instance with specific arguments or with "placeholders".</p>
<p>[code language="cpp"]auto equalToA1 = std::bind(<br />
    std::equal_to&lt;A*&gt;(),<br />
    std::placeholders::_1,<br />
    a1.get()<br />
);[/code]</p>
<p>Here, <code>std::bind</code> is called with three arguments because the Callable supplied as the first argument expects two parameters. Thus there are two parameters that can be bound. The first argument, <code>std::placeholders::_1</code>, can be understood as the first parameter of the <code>operator()</code> method of the functor being created. The second argument, <code>a1</code>, is more straightforward: the contained pointer is simply passed along as the second parameter of the wrapped Callable. A new version of the predicate can now be written using this tool:</p>
<p>[code language="cpp" highlight="8"]auto predicate3 = [equalToA1](B* b) -&gt; bool {<br />
    return equalToA1(b-&gt;getA());<br />
};<br />
std::copy_if(<br />
    objects.begin(),<br />
    objects.end(),<br />
    std::back_inserter(result),<br />
    predicate3<br />
);</p>
<p>// Result : {1, 3, 5}[/code]</p>
<p>Now there is one missing piece in our puzzle. A functor with the signature <code>bool(A*)</code> was successfully created, but <code>std::count_if</code> expects a predicate with the signature <code>bool(B*)</code>. Up to now, a lambda expression was used to call <code>B::getA()</code> before passing the result to <code>predicate3</code>. The next step is to get rid of the lambda expression altogether.</p>
<p>In order to do so, a functor with the signature <code>A*(B*)</code> that does its job by calling <code>B::getA()</code> has to be created:</p>
<p>[code language="cpp"]struct MethodWrapper<br />
{<br />
    MethodWrapper(A*(B::*method)()) : method(method) {}</p>
<p>    A* operator()(B* instance) const<br />
    {<br />
        return (instance-&gt;*method)();<br />
    }</p>
<p>    A*(B::*method)();<br />
};[/code]</p>
<p>This last piece of code has a pretty weird syntax. <code>A*(B::*method)()</code> is a pointer to member of <code>B</code> named <code>method</code> that returns <code>A*</code>. In order to use this pointer to achieve a method call, the -&gt;* operator is used to bind <code>instance</code> as <code>this</code> within <code>B::getA()</code>. Then, the result of this operator must absolutely be enclosed within parentheses before being called. As a last step, another functor is required to compose the calls to two functors.</p>
<p>[code language="cpp"]struct ComposingWrapper<br />
{<br />
    ComposingWrapper(std::function&lt;bool(A*)&gt; f, std::function&lt;A*(B*)&gt; g) : f(f), g(g) {}</p>
<p>    bool operator()(B* b)<br />
    {<br />
        return f(g(b));<br />
    }</p>
<p>public:<br />
    std::function&lt;bool(A*)&gt; f;<br />
    std::function&lt;A*(B*)&gt; g;<br />
};[/code]</p>
<p>[code language="cpp" highlight="5"]std::copy_if(<br />
    objects.begin(),<br />
    objects.end(),<br />
    std::back_inserter(result),<br />
    ComposingWrapper(equalToA1, MethodWrapper(&amp;B::getA))<br />
);</p>
<p>// Result : {1, 3, 5}[/code]</p>
<p>When instantiating <code>ComposingWrapper</code>, a pointer to member of class <code>B</code> is obtained with the syntax <code>&amp;B::getA</code>. The <code>operator&amp;</code> here has the same meaning as it usually does: it returns the address of its operand.</p>
<p>As you may have guessed at this point, it is not necessary to write functors manually. There are two more things <code>std::bind</code> has to offer for this particular problem.</p>
<p>First, <code>std::bind</code>'s first parameter can be a pointer to member of class. Then, in addition to that method's parameters, an additional parameter representing <code>this</code> will need to be bound. Accordingly, a method without any parameter has a single parameter to bind : <code>this</code>.</p>
<p>[code language="cpp"]std::bind(<br />
    &amp;B::getA,<br />
    std::placeholders::_1<br />
);<br />
[/code]</p>
<p>Second, the result of calling <code>std::bind</code> can be used as an argument for another call to <code>std::bind</code> which makes it possible to make function composition.</p>
<p>[code language="cpp"]auto predicate4 = std::bind(<br />
    std::equal_to&lt;A*&gt;(),<br />
    std::bind(<br />
        &amp;B::getA,<br />
        std::placeholders::_1<br />
    ),<br />
    a2.get()<br />
);[/code]</p>
<p>The outermost functor will be built by taking account of the innermost functor which requires a single argument of type <code>B*</code>. Thus the outermost functor will also require a single argument of type <code>B*</code>. A functor with the signature <code>bool(B*)</code> has been successfully created.</p>
<p>[code language="cpp" highlight="5"]std::copy_if(<br />
    objects.begin(),<br />
    objects.end(),<br />
    std::back_inserter(result),<br />
    predicate4<br />
);</p>
<p>// Result : {2, 4}[/code]</p>
<p>There is one gotcha that will inevitably happen in a real codebase. Here is a new definition for <code>class B</code> where a subtle modification will make it harder to compose our functions:</p>
<p>[code language="cpp"]class B<br />
{<br />
public:<br />
    B(int i, A* a) : i(i), a(a) {}</p>
<p>    A* getA() {return a;}<br />
    A* getA() const {return a;}</p>
<p>public:<br />
    int i;<br />
    A* a;<br />
};<br />
[/code]</p>
<p>Now the definition of <code>predicate4<code> results in the error: "No matching function for call to 'bind'". Secondary messages read: "Candidate template ignored: couldn't infer template argument '_Fp'" and "Candidate template ignored: couldn't infer template argument '_Rp'". It turns out that adding a <code>const</code> overload of our function has created an ambiguity in the call to <code>std::bind</code> and the compiler is giving us cryptic error messages. In order to disambiguate the bind expression, we need a <code>static_cast</code>:</code></code></p>
<p>[code language="cpp" highlight="14"]auto predicate4 = std::bind(<br />
    std::equal_to&lt;A*&gt;(),<br />
    std::bind(<br />
        static_cast&lt;A*(B::*)()&gt;(&amp;B::getA),<br />
        std::placeholders::_1<br />
    ),<br />
    a<br />
);</p>
<p>std::copy_if(<br />
    objects.begin(),<br />
    objects.end(),<br />
    std::back_inserter(result),<br />
    predicate4<br />
);[/code]</p>
<p>An important note about using <code>std::bind</code> is that function composition cannot be accomplished with any Callable (i. e.: <code>std::function</code>). Function composition happens if <code>std::is_bind_expression&lt;T&gt;::value == true</code> for one of the arguments supplied to <code>std::bind</code>. This presumably means it would be possible to specialize a few templates so that a custom function wrapper can be used in function composition, but this possibility won't be explored in this article.</p>
<h3>Conclusion</h3>
<p>Four different predicate creation techniques for standard algorithms were presented in this article:</p>
<ol>
<li>Function</li>
<li>Hand-written Functor</li>
<li>Lambda</li>
<li>std::bind generated Functor</li>
</ol>
<p>For any new C++11 code, functions should be avoided as they lack flexibility because they do not hold any state. As for functors, unless there are other requirements beside the bool operator(T) const method, then lambdas are always preferable as they reduce the boilerplate and make the process less error-prone. Finally, this article doesn't have any advice on whether to prefer lambdas over std::bind or the opposite, both seem equally capable.</p>
<p>The complete code for this article can be found over here : https://github.com/Dalzhim/ArticlePredicateTechniques</p>
